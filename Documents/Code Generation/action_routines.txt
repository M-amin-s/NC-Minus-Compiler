VARIABLE, ARRAY AND FUNCTION DECLARATON:
TODO: FUNCTION DECLARATION

#ptype_int_dec begin:
ss.push('int')
end

#ptype_void_dec begin:
ss.push('void')
end

#pid_dec begin:
name <- get_input
ss.push(name)
scp <- scope
ss.push(scp)
addr <- data_ptr
ss.push(addr)
data_ptr += 4
end

#var_dec_finish begin:
var_scope_stack.push((ss[ss_top-2], ss[ss_top-1], ss[ss_top-3], ss[ss_top]))
ss.pop(4)
end

#arr_len_dec begin:
len <- get_input
ss.push(len)
end

#arr_dec_finish begin:
end = ss[ss_top-1] + 4 * ss[ss_top]
arr_scope_stack.push((ss[ss_top-3], ss[ss_top-2], ss[ss_top-4], ss[ss_top-1], end))
ss.pop(5)
end

SCOPE HANDLING:

#enter_scope begin:
scope.push(scope_id + 1)
scope_id <- scope_id + 1
end

#exit_scope begin:
scope.pop(1)
end

IF STATEMENTS:

#if_jmpc_else begin:
ss.push(program_ptr)
program_ptr += 1
end

#if_jmpu_end begin:
ss.push(program_ptr)
program_ptr += 1
end

#if_label_else begin:
program_block[ss[top-1]] <- (JPF, ss[top_ss-2], program_ptr,)
end

#if_label_end begin:
program_block[ss[top]] <- (JP, program_ptr,,)
end

EXPRESSION HANDLING:
TODO: PUSH RESULT ON SS

WHILE STATEMENTS:

#while_label_start begin:
ss.push(program_ptr)
end

#while_jmpc_end begin:
ss.push(program_ptr)
program_ptr += 1
end

#while_jmpu_start begin:
program_block[program_ptr] <- (JP, ss[top_ss-2],,)
end

#while_label_end begin:
program_block[ss[top]] <- (JPF, ss[top_ss-1], program_ptr + 1,)
end

SWITCH CASE EXPRESSIONS:

#switch_jmpu_ignore begin:
program_ptr += 1
end

#switch_label_start begin:

end

#switch_jmpu_end begin:
ss.push(program_ptr)
program_ptr += 1
end

#switch_label_ignore begin:
program_block[program_ptr - 2] <- (JP, program_ptr,,)
end

#switch_label_end begin:
program_block[ss[top_ss - 1]] <- (JP, program_ptr,,)
pop(2)
end

#switch_jmpc_skip begin:
t <- temp_ptr
temp_ptr += 4
program_block[program_ptr] <- (EQ, ss[top_ss], ss[top_ss - 1], t)
pop(1)
ss.push(t)
program_ptr += 1
ss.push(program_ptr)
program_ptr += 1
end

#switch_jmpu_start begin:
program_block[program_ptr] <- (JP, ss[top_ss - 3],,)
program_ptr += 1
end

#switch_label_skip begin:
program_block[ss[top_ss]] <- (JPF, ss[top_ss - 1], program_ptr,)
pop(2)
end

--------------------------------------------------------------------------
EXPRESSIONS:

#push_ss begin:
num <- get_input
ss.push(num)
end

#pid_ref begin:
name <- get_input
address <- search in var_scope_stack and arr_scope_stack for name and check if it's in the same scope or outer scopes,
and get the address
ss.push(address)
end

#arr_ref begin:
element_addr <- 4*ss[top_ss] + ss[top_ss-1]
ss.pop(2)
ss.push(element_addr)
end

#assignment begin:
program_block[program_ptr] <- (ASSIGN, ss[top_ss], ss[top_ss - 1),)
program_ptr += 1
pop(2)
end

#multop begin:
program_block[program_ptr] <- (MULT, ss[top_ss], ss[top_ss - 1], tmp_ptr)
ss.pop(2)
ss.push(tmp_ptr)
tmp_ptr += 4
program_ptr += 1
end

#addop_p begin:
ss.push(#0)
end

#addop_m begin:
ss.push(#1)
end

#addop begin:
if (ss[top_ss-1] == 0)
    program_block[program_ptr] <- (ADD, ss[top], ss[top-2], tmp_ptr)
elif (ss[top_ss-1] == 1)
    program_block[program_ptr] <- (ADD, ss[top], ss[top-2], tmp_ptr)
ss.pop(3)
ss.push(tmp_ptr)
tmp_ptr += 4
program_ptr += 1
end

#relop_lt begin:
ss.push(#0)
end

#relop_eq begin:
ss.push(#1)
end

#relop begin:
if (ss[top_ss-1] == 0)
    program_block[program_ptr] <- (LT, ss[top-2], ss[top], tmp_ptr)
elif (ss[top_ss-1] == 1)
    program_block[program_ptr] <- (EQ, ss[top], ss[top-2], tmp_ptr)
ss.pop(3)
ss.push(tmp_ptr)
tmp_ptr += 4
program_ptr += 1
end

#negate_factor begin:
program_block[program_ptr] <- (SUB, ss[top], #0, tmp_ptr)
ss.pop(1)
ss.push(tmp_ptr)
tmp_ptr += 4
program_ptr += 1
end

#push_num_exp begin:
num <- get_input
ss.push(num)
end

#call_function begin:

end

#EXIT begin:

end